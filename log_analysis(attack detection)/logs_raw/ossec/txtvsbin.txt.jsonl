{"event": "A Fast Method for Identifying Plain Text Files"}
{"event": "=============================================="}
{"event": "Introduction"}
{"event": "------------"}
{"event": "Given a file coming from an unknown source, it is sometimes desirable"}
{"event": "to find out whether the format of that file is plain text.  Although"}
{"event": "this may appear like a simple task, a fully accurate detection of the"}
{"event": "file type requires heavy-duty semantic analysis on the file contents."}
{"event": "It is, however, possible to obtain satisfactory results by employing"}
{"event": "various heuristics."}
{"event": "Previous versions of PKZip and other zip-compatible compression tools"}
{"event": "were using a crude detection scheme: if more than 80% (4/5) of the bytes"}
{"event": "found in a certain buffer are within the range [7..127], the file is"}
{"event": "labeled as plain text, otherwise it is labeled as binary.  A prominent"}
{"event": "limitation of this scheme is the restriction to Latin-based alphabets."}
{"event": "Other alphabets, like Greek, Cyrillic or Asian, make extensive use of"}
{"event": "the bytes within the range [128..255], and texts using these alphabets"}
{"event": "are most often misidentified by this scheme; in other words, the rate"}
{"event": "of false negatives is sometimes too high, which means that the recall"}
{"event": "is low.  Another weakness of this scheme is a reduced precision, due to"}
{"event": "the false positives that may occur when binary files containing large"}
{"event": "amounts of textual characters are misidentified as plain text."}
{"event": "In this article we propose a new, simple detection scheme that features"}
{"event": "a much increased precision and a near-100% recall.  This scheme is"}
{"event": "designed to work on ASCII, Unicode and other ASCII-derived alphabets,"}
{"event": "and it handles single-byte encodings (ISO-8859, MacRoman, KOI8, etc.)"}
{"event": "and variable-sized encodings (ISO-2022, UTF-8, etc.).  Wider encodings"}
{"event": "(UCS-2/UTF-16 and UCS-4/UTF-32) are not handled, however."}
{"event": "The Algorithm"}
{"event": "-------------"}
{"event": "The algorithm works by dividing the set of bytecodes [0..255] into three"}
{"event": "categories:"}
{"event": "- The white list of textual bytecodes:"}
{"event": "9 (TAB), 10 (LF), 13 (CR), 32 (SPACE) to 255."}
{"event": "- The gray list of tolerated bytecodes:"}
{"event": "7 (BEL), 8 (BS), 11 (VT), 12 (FF), 26 (SUB), 27 (ESC)."}
{"event": "- The black list of undesired, non-textual bytecodes:"}
{"event": "0 (NUL) to 6, 14 to 31."}
{"event": "If a file contains at least one byte that belongs to the white list and"}
{"event": "no byte that belongs to the black list, then the file is categorized as"}
{"event": "plain text; otherwise, it is categorized as binary.  (The boundary case,"}
{"event": "when the file is empty, automatically falls into the latter category.)"}
{"event": "Rationale"}
{"event": "---------"}
{"event": "The idea behind this algorithm relies on two observations."}
{"event": "The first observation is that, although the full range of 7-bit codes"}
{"event": "[0..127] is properly specified by the ASCII standard, most control"}
{"event": "characters in the range [0..31] are not used in practice.  The only"}
{"event": "widely-used, almost universally-portable control codes are 9 (TAB),"}
{"event": "10 (LF) and 13 (CR).  There are a few more control codes that are"}
{"event": "recognized on a reduced range of platforms and text viewers/editors:"}
{"event": "7 (BEL), 8 (BS), 11 (VT), 12 (FF), 26 (SUB) and 27 (ESC); but these"}
{"event": "codes are rarely (if ever) used alone, without being accompanied by"}
{"event": "some printable text.  Even the newer, portable text formats such as"}
{"event": "XML avoid using control characters outside the list mentioned here."}
{"event": "The second observation is that most of the binary files tend to contain"}
{"event": "control characters, especially 0 (NUL).  Even though the older text"}
{"event": "detection schemes observe the presence of non-ASCII codes from the range"}
{"event": "[128..255], the precision rarely has to suffer if this upper range is"}
{"event": "labeled as textual, because the files that are genuinely binary tend to"}
{"event": "contain both control characters and codes from the upper range.  On the"}
{"event": "other hand, the upper range needs to be labeled as textual, because it"}
{"event": "is used by virtually all ASCII extensions.  In particular, this range is"}
{"event": "used for encoding non-Latin scripts."}
{"event": "Since there is no counting involved, other than simply observing the"}
{"event": "presence or the absence of some byte values, the algorithm produces"}
{"event": "consistent results, regardless what alphabet encoding is being used."}
{"event": "(If counting were involved, it could be possible to obtain different"}
{"event": "results on a text encoded, say, using ISO-8859-16 versus UTF-8.)"}
{"event": "There is an extra category of plain text files that are \"polluted\" with"}
{"event": "one or more black-listed codes, either by mistake or by peculiar design"}
{"event": "considerations.  In such cases, a scheme that tolerates a small fraction"}
{"event": "of black-listed codes would provide an increased recall (i.e. more true"}
{"event": "positives).  This, however, incurs a reduced precision overall, since"}
{"event": "false positives are more likely to appear in binary files that contain"}
{"event": "large chunks of textual data.  Furthermore, \"polluted\" plain text should"}
{"event": "be regarded as binary by general-purpose text detection schemes, because"}
{"event": "general-purpose text processing algorithms might not be applicable."}
{"event": "Under this premise, it is safe to say that our detection method provides"}
{"event": "a near-100% recall."}
{"event": "Experiments have been run on many files coming from various platforms"}
{"event": "and applications.  We tried plain text files, system logs, source code,"}
{"event": "formatted office documents, compiled object code, etc.  The results"}
{"event": "confirm the optimistic assumptions about the capabilities of this"}
{"event": "algorithm."}
{"event": "--"}
{"event": "Cosmin Truta"}
{"event": "Last updated: 2006-May-28"}
